# Assignment 3 – Reflection on ETL Pipeline Redesign

In Assignment 2, my ETL pipeline was written almost entirely inside a single Java class. That design worked and met the requirements, but it became clear that it was not very flexible or easy to maintain. The extraction, transformation, and loading steps were all bundled together, which made the code harder to read and left little room for growth. If I had wanted to add a new data source or change how one step worked, I would have had to dig through a large class and risk breaking something else. In short, the Assignment 2 design was functional but not strongly object-oriented.

When I moved to Assignment 3, I redesigned the pipeline to be more modular and object-oriented. In Assignment 2 all logic was inside a single ETLPipeline class, while Assignment 3 uses separate classes, each with a clear responsibility. A `Product` class now represents a single row from the CSV file, holding details such as the ID, name, price, and category. A `CSVExtractor` class is responsible only for reading the input file and turning rows into `Product` objects. A `Transformer` class handles all of the business rules: converting product names to uppercase, applying discounts to Electronics, changing categories when necessary, and calculating price ranges. A `CSVLoader` class focuses on writing the transformed data back to a file. Finally, an `ETLPipelineApp` class coordinates the entire process by running the extract–transform–load steps in order and printing a summary of the run. I also introduced a `MissingInputException` class to handle the case where the input file is missing, which made the program’s error handling cleaner.

This redesign made the pipeline much more object-oriented. Each class encapsulates its own behavior, hiding unnecessary details from other parts of the program. The program makes stronger use of abstraction by modeling the pipeline steps as real objects, which gives the code a structure that reflects the logical process of ETL. Even though I did not make heavy use of inheritance or polymorphism, the design could easily be extended in the future. For example, it would be simple to add a `JSONExtractor` or `DatabaseLoader` without changing the other parts of the code. Most importantly, the new design respects the principle of separation of concerns: each class now has a single responsibility, which makes the program easier to maintain and expand.

To confirm that the new design still worked, I tested Assignment 3 using the same input files from Assignment 2. With normal input, the program produced the correct transformations, including uppercase names, discounts, Premium recategorization, and price ranges. With an empty input file, the program correctly generated an output with only the header row. Finally, when the input file was missing, the program threw the custom `MissingInputException` and displayed a clear error message. The outputs of Assignment 3 matched the results from Assignment 2 in all cases, which shows that the redesign preserved functionality while improving structure.

Overall, I consider the redesign a success. Assignment 2 solved the problem in a direct but somewhat rigid way, while Assignment 3 reorganized the same logic into a set of classes that better reflect object-oriented principles. The new design is easier to understand, easier to test, and easier to extend in the future. While not perfect, it represents a clear step toward writing programs that are not only correct, but also well-designed and maintainable.